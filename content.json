[{"title":"Rxjs Marble Diagrams","date":"2017-09-28T04:57:00.000Z","path":"2017/09/28/Rxjs Marble Diagrams/","text":"我們用 - 來表達一小段時間，這些 - 串起就代表一個 observable。1---------------- X (大寫 X)則代表有錯誤發生1---------------X | 則代表 observable 結束1----------------| 1. ofobservable 是同步送值的時候, 小括號代表著同步發生。1var source = Rx.Observable.of(1,2,3,4); 1(1234)| 2. interval1var source = Rx.Observable.interval(1000); 1-----0-----1-----2-----3--... 3. map1234567var source = Rx.Observable.interval(1000);var newest = source.map(x =&gt; x + 2); newest.subscribe(console.log);// 2// 3// 4// 5.. 123source: -----0-----1-----2-----3--... map(x =&gt; x + 1)newest: -----1-----2-----3-----4--... 4. mapTo1234567var source = Rx.Observable.interval(1000);var newest = source.mapTo(2); newest.subscribe(console.log);// 2// 2// 2// 2.. 123source: -----0-----1-----2-----3--... mapTo(2)newest: -----2-----2-----2-----2--... 5. filter12345678var source = Rx.Observable.interval(1000);var newest = source.filter(x =&gt; x % 2 === 0); newest.subscribe(console.log);// 0// 2// 4// 6.. 123source: -----0-----1-----2-----3-----4-... filter(x =&gt; x % 2 === 0)newest: -----0-----------2-----------4-... 6. take123456789101112var source = Rx.Observable.interval(1000);var example = source.take(3);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 0// 1// 2// complete 123source : -----0-----1-----2-----3--.. take(3)example: -----0-----1-----2| 7. first和 take(1)一致1234567891011var source = Rx.Observable.interval(1000);var example = source.first();example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 0// complete 123source : -----0-----1-----2-----3--.. first()example: -----0| 8. takeLasttakeLast 必須等到整個 observable 完成(complete)，才能知道最後的元素有哪些，並且同步送出1234567891011var source = Rx.Observable.interval(1000).take(6);var example = source.takeLast(2);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 4// 5// complete 123source : ----0----1----2----3----4----5| takeLast(2)example: ------------------------------(45)| 9. last相当于 takeLast(1)，用來取得最後一個元素。12345678910var source = Rx.Observable.interval(1000).take(6);var example = source.last();example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 5// complete 123source : ----0----1----2----3----4----5| last()example: ------------------------------(5)| 10. takeUntil當 takeUntil 傳入的 observable 發送值時，原本的 observable 就會直接進入完成(complete)的狀態，並且發送完成訊息。1234567891011121314var source = Rx.Observable.interval(1000);var click = Rx.Observable.fromEvent(document.body, 'click');var example = source.takeUntil(click); example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 0// 1// 2// 3// complete (點擊body了) 1234source : -----0-----1-----2------3--click : ----------------------c---- takeUntil(click)example: -----0-----1-----2----| 11. concatconcat 可以把多個 observable 實例合併成一個123456789101112131415161718var source = Rx.Observable.interval(1000).take(3);var source2 = Rx.Observable.of(3)var source3 = Rx.Observable.of(4,5,6)var example = source.concat(source2, source3);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 0// 1// 2// 3// 4// 5// 6// complete 12345source : ----0----1----2|source2: (3)|source3: (456)| concat()example: ----0----1----2(3456)| 另外 concat 還可以當作靜態方法使用12345678910var source = Rx.Observable.interval(1000).take(3);var source2 = Rx.Observable.of(3);var source3 = Rx.Observable.of(4,5,6);var example = Rx.Observable.concat(source, source2, source3);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 12. concatAllObservable 送出的元素又是一個 observable，就像是二維陣列，陣列裡面的元素是陣列，可以用 concatAll 把它攤平成一維陣列. 把二维阵列变成维.123456789var click = Rx.Observable.fromEvent(document.body, 'click');var source = click.map(e =&gt; Rx.Observable.of(1,2,3));var example = source.concatAll();example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 1234567891011click : ------c------------c-------- map(e =&gt; Rx.Observable.of(1,2,3))source : ------o------------o-------- \\ \\ (123)| (123)| concatAll()example: ------(123)--------(123)------------ 這裡需要注意的是 concatAll 會處理 source 先發出來的 observable，必須等到這個 observable 結束，才會再處理下一個 source 發出來的 observable。12345678910111213141516171819202122var obs1 = Rx.Observable.interval(1000).take(5);var obs2 = Rx.Observable.interval(500).take(2);var obs3 = Rx.Observable.interval(2000).take(1);var source = Rx.Observable.of(obs1, obs2, obs3);var example = source.concatAll();example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 0// 1// 2// 3// 4// 0// 1// 0// complete 1234567source : (o1 o2 o3)| \\ \\ \\ --0--1--2--3--4| -0-1| ----0| concatAll() example: --0--1--2--3--4-0-1----0| 13. skip原本從 0 開始的就會變成從 3 開始，但是記得原本元素的等待時間仍然存在，也就是說此範例第一個取得的元素需要等 4 秒，用 Marble Diagram 表示如下。1234567891011var source = Rx.Observable.interval(1000);var example = source.skip(3);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 3// 4// 5... 123source : ----0----1----2----3----4----5--.... skip(3)example: -------------------3----4----5--... 14. startWithstartWith 的值是一開始就同步發出的，這個 operator 很常被用來保存程式的起始狀態！下面的例子，不会过1秒才出现0，而是马上出现012345678910111213var source = Rx.Observable.interval(1000);var example = source.startWith(0);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 0 马上发出// 0 过1秒// 1// 2// 3... 123source : ----0----1----2----3--... startWith(0)example: (0)----0----1----2----3--... 15. mergemerge 把多個 observable 同時處理，這跟 concat 一次處理一個 observable 是完全不一樣的.12345678910111213141516171819var source = Rx.Observable.interval(500).take(3);var source2 = Rx.Observable.interval(300).take(6);var example = source.merge(source2);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 0// 0// 1// 2// 1// 3// 2// 4// 5// complete 1234source : ----0----1----2|source2: --0--1--2--3--4--5| merge()example: --0-01--21-3--(24)--5| 這很常用在一個以上的按鈕具有部分相同的行為。例如一個影片播放器有兩個按鈕，一個是暫停(II)，另一個是結束播放(口)。這兩個按鈕都具有相同的行為就是影片會被停止，只是結束播放會讓影片回到 00 秒，這時我們就可以把這兩個按鈕的事件 merge 起來處理影片暫停這件事。 12345var stopVideo = Rx.Observable.merge(stopButton, endButton);stopVideo.subscribe(() =&gt; &#123; // 暫停播放影片&#125;) 非同步最難的地方在於，當有多個非同步行為同時觸發且相互依賴，這時候我們要處理的邏輯跟狀態就會變得極其複雜.它們都是在多個元素送進來時，只輸出一個新元素. 16. combineLatest它會取得各個 observable 最後送出的值，再輸出成一個值.描述: 1. newest 和 source 其中一个送出值的时候 2. 和另外一个最新送出的值 3. 传入callback 4. 当newest 和 source 都结束了, 才会complete 例子流程: * newest 送出了 `0`，source 没有送出，不會執行 callback * source 送出了 `0`，newest 送出`0`，callback 等于 `0` * newest 送出了 `1`，source 送出 `0`，callback 等于 `1` ........................ * newest 和 source 都結束了，complete 12345678910111213141516171819var source = Rx.Observable.interval(500).take(3);var newest = Rx.Observable.interval(300).take(6);var example = source.combineLatest(newest, (x, y) =&gt; x + y);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 0// 1// 2// 3// 4// 5// 6// 7// complete 123456source : ----0----1----2|newest : --0--1--2--3--4--5| combineLatest(newest, (x, y) =&gt; x + y);example: ----01--23-4--(56)--7| 应用:combineLatest 很常用在運算多個因子的結果;A 和 B的值求出C, A 变化, 则C变化; B变化, 则C也变化 17. zip描述: 1. newest 和 source 其中一个送出值的时候 2. 若当前另1个同位置有值 3. 传入callback 4. 任意1个结束, 就会complete 例子流程: newest 送出了 0，source没有送出，不會執行 callback source 送出了 0，newest送出0，callback 等于 0….. 一直不执行callback source 送出了 1，newest虽然现在最新的是2，但是之前送出的是 1，callback等于2(1+1)….. 一直不执行callback source 送出了 2，newest之前送出的是 2， callback 等于 4 source 結束 example 就結束，因為 source 跟 newest 不會再有對應位置的值 1234567891011121314var source = Rx.Observable.interval(500).take(3);var newest = Rx.Observable.interval(300).take(6);var example = source.zip(newest, (x, y) =&gt; x + y);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 0// 2// 4// complete 1234source : ----0----1----2|newest : --0--1--2--3--4--5| zip(newest, (x, y) =&gt; x + y)example: ----0----2----4| 应用: zip 适用原本只能同步送出的資料變成了非同步的, 常拿來做 demo 使用，比如：1234var source = Rx.Observable.from('hello');var source2 = Rx.Observable.interval(100);var example = source.zip(source2, (x, y) =&gt; x); 1234source : (hello)|source2: -0-1-2-3-4-... zip(source2, (x, y) =&gt; x)example: -h-e-l-l-o| 18. withLatestFromwithLatestFrom 運作方式跟 combineLatest 有點像，只是他有主從的關係，只有在主要的 observable 送出新的值時，才會執行 callback，附隨的 observable 只是在背景下運作描述: 1. main 送出值的时候 2. 和另外一个最新送出的值 3. 传入callback 4. main结束时, 就会complete 例子流程: main 送出了 h，some 上一次送出的值為 0，callback 得到 h。 main 送出了 e，some 上一次送出的值為 0，callback 得到 e。 main 送出了 l，some 上一次送出的值為 0，callback 得到 l。 main 送出了 l，some 上一次送出的值為 1，callback 得到 L。 main 送出了 o，some 上一次送出的值為 1，callback 得到 O。 123456789101112var main = Rx.Observable.from('hello').zip(Rx.Observable.interval(500), (x, y) =&gt; x);var some = Rx.Observable.from([0,1,0,0,0,1]).zip(Rx.Observable.interval(300), (x, y) =&gt; x);var example = main.withLatestFrom(some, (x, y) =&gt; &#123; return y === 1 ? x.toUpperCase() : x;&#125;);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 123456main : ----h----e----l----l----o|some : --0--1--0--0--0--1|withLatestFrom(some, (x, y) =&gt; y === 1 ? x.toUpperCase() : x);example: ----h----e----l----L----O| 应用:withLatestFrom 很常用在一些 checkbox 型的功能，例如說一個編輯器，我們開啟粗體後，打出來的字就都要變粗體，粗體就像是 some observable，而我們打字就是 main observable。 19. scan12345678910111213141516var source = Rx.Observable.from('hello') .zip(Rx.Observable.interval(600), (x, y) =&gt; x);var example = source.scan((origin, next) =&gt; origin + next, '');example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// h// he// hel// hell// hello// complete 123source : ----h----e----l----l----o| scan((origin, next) =&gt; origin + next, &apos;&apos;)example: ----h----(he)----(hel)----(hell)----(hello)| scan 很常用在狀態的計算處理，最簡單的就是對一個數字的加減，我們可以綁定一個 button 的 click 事件，並用 map 把 click event 轉成 1，之後送處 scan 計算值再做顯示。12345678910111213141516171819const addButton = document.getElementById('addButton');const minusButton = document.getElementById('minusButton');const state = document.getElementById('state');const addClick = Rx.Observable.fromEvent(addButton, 'click').mapTo(1);const minusClick = Rx.Observable.fromEvent(minusButton, 'click').mapTo(-1);const numberState = Rx.Observable.empty() .startWith(0) .merge(addClick, minusClick) .scan((origin, next) =&gt; origin + next, 0) numberState .subscribe(&#123; next: (value) =&gt; &#123; state.innerHTML = value;&#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125; &#125;); 20. buffer5个相关的operator buffer bufferCount bufferTime bufferToggle bufferWhen buffer 要傳入一個 observable(source2)，它會把原本的 observable (source)送出的元素緩存在陣列中，等到傳入的 observable(source2) 送出元素時，就會觸發把緩存的元素送出。12345678910111213141516var source = Rx.Observable.interval(300); /* 相当于 var source2 = source.bufferTime(1000); */var source2 = Rx.Observable.interval(1000);var example = source.buffer(source2);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// [0,1,2]// [3,4,5]// [6,7,8]... 1234source : --0--1--2--3--4--5--6--7..source2: ---------0---------1--------... buffer(source2)example: ---------([0,1,2])---------([3,4,5]) 除了用時間來作緩存外，我們更常用數量來做緩存，範例如下:1234567891011var source = Rx.Observable.interval(300);var example = source.bufferCount(3);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// [0,1,2]// [3,4,5]// [6,7,8]... 可以用 buffer 來做某個事件的過濾，例如像是滑鼠連點才能真的執行，這裡我們只有在 500 毫秒內連點兩下，才能成功印出 ‘success’，這個功能在某些特殊的需求中非常的好用，也能用在批次處理來降低 request 傳送的次數！代码如下:1234567891011const button = document.getElementById('demo');const click = Rx.Observable.fromEvent(button, 'click')const example = click .bufferTime(500) .filter(arr =&gt; arr.length &gt;= 2);example.subscribe(&#123; next: (value) =&gt; &#123; console.log('success'); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 21. delay1234567891011121314var source = Rx.Observable.interval(300).take(5);var example = source.delay(500);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 0// 1// 2// 3// 4 123source : --0--1--2--3--4| delay(500)example: -------0--1--2--3--4| delay 除了可以傳入毫秒以外，也可以傳入 Date 型別的資料123456789var source = Rx.Observable.interval(300).take(5);var example = source.delay(new Date(new Date().getTime() + 1000));example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 22. delayWhendelayWhen 可以影響每個元素，而且需要傳一個 callback 並回傳一個 observable123456789101112var source = Rx.Observable.interval(300).take(5);var example = source .delayWhen( x =&gt; Rx.Observable.empty().delay(100 * x * x) );example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 123source : --0--1--2--3--4| .delayWhen(x =&gt; Rx.Observable.empty().delay(100 * x * x));example: --0---1----2-----3-----4| 23. debouncedebounce 跟 debounceTime 一個是傳入 observable 另一個則是傳入毫秒，比較常用到的是 debounceTime描述: 每次收到元素，等待1000毫秒 若1000毫秒内没有元素送出, 则把最新收到的元素送出; 若1000毫秒内收到新的元素, 重新等待1000毫秒. 注意若是最后一个元素, 则不需要等待 1000 毫秒, 直接送出 12345678910var source = Rx.Observable.interval(300).take(5);var example = source.debounceTime(1000);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 4// complete 123source : --0--1--2--3--4| debounceTime(1000)example: --------------4| 具体例子, 自動傳送使用者打的字到後端:12345678910const searchInput = document.getElementById('searchInput');const theRequestValue = document.getElementById('theRequestValue');Rx.Observable.fromEvent(searchInput, 'input') .debounceTime(300) .map(e =&gt; e.target.value) .subscribe((value) =&gt; &#123; theRequestValue.textContent = value; // 在這裡發 request &#125;) 24. throttle描述: 第1次收到元素先送出, 1000毫秒以内处于关闭状态, 1000毫秒后, 若收到元素, 则送出 最后1个元素不一定会送出 123456789101112var source = Rx.Observable.interval(400).take(8);var example = source.throttleTime(1000);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;);// 0// 3// 6// complete 123source : ---0---1---2---3---4---5---6---7| throttleTime(1000)example: ---0-----------3-----------6----| 下面要说3个处理 Higher Order Observable. 所謂的 Higher Order Observable 就是指一個 Observable 送出的元素還是一個 Observable，就像是二維陣列一樣，一個陣列中的每個元素都是陣列。一共有3个方法: concatAll mergeAll switch 25. concatAllconcatAll 會一個一個處理，一定是等前一個 observable 完成(complete)才會處理下一個 observable 123456789var click = Rx.Observable.fromEvent(document.body, 'click');var source = click.map(e =&gt; Rx.Observable.interval(1000).take(3));var example = source.concatAll();example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 12345678click : ---------c-c------------------c--.. map(e =&gt; Rx.Observable.interval(1000))source : ---------o-o------------------o--.. \\ \\ \\ \\ ----0----1----2| ----0----1----2| ----0----1----2| concatAll()example: ----------------0----1----2----0----1----2--.. 26. switch当有新的 observable 来的时候, 就会把旧的退訂, 永远只处理新的 observable.下面的例子, 当第2次点击的时候，由于第2个observable和第1个时间小于1秒，所以第1个就被退订了123456789var click = Rx.Observable.fromEvent(document.body, 'click');var source = click.map(e =&gt; Rx.Observable.interval(1000));var example = source.switch();example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 12345678click : ---------c-c------------------c--.. map(e =&gt; Rx.Observable.interval(1000))source : ---------o-o------------------o--.. \\ \\ \\----0----1--... \\ ----0----1----2----3----4--... ----0----1----2----3----4--... switch()example: -----------------0----1----2--------0----1--... 27. mergeAll它會把二維的 observable 轉成一維的，並且能夠同時處理所有的 observable。若传入的参数是1, 则和concatAll是一摸一样的123456789var click = Rx.Observable.fromEvent(document.body, 'click');var source = click.map(e =&gt; Rx.Observable.interval(1000));var example = source.mergeAll();example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 12345678click : ---------c-c------------------c--.. map(e =&gt; Rx.Observable.interval(1000))source : ---------o-o------------------o--.. \\ \\ \\----0----1--... \\ ----0----1----2----3----4--... ----0----1----2----3----4--... switch()example: ----------------00---11---22---33---(04)4--... 另外 mergeAll 可以傳入一個數值，這個數值代表他可以同時處理的 observable 數量123456789var click = Rx.Observable.fromEvent(document.body, 'click');var source = click.map(e =&gt; Rx.Observable.interval(1000).take(3));var example = source.mergeAll(2);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 12345678click : ---------c-c----------o----------.. map(e =&gt; Rx.Observable.interval(1000))source : ---------o-o----------c----------.. \\ \\ \\----0----1----2| \\ ----0----1----2| ----0----1----2| mergeAll(2)example: ----------------00---11---22---0----1----2--.. 28. concatMapconcatMap= map+concatAll12345678910var source = Rx.Observable.fromEvent(document.body, 'click');var example = source .map(e =&gt; Rx.Observable.interval(1000).take(3)) .concatAll();example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 相当于1234567891011var source = Rx.Observable.fromEvent(document.body, 'click');var example = source .concatMap( e =&gt; Rx.Observable.interval(100).take(3) ); example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); Marble Diagram:123source : -----------c--c------------------... concatMap(c =&gt; Rx.Observable.interval(100).take(3))example: -------------0-1-2-0-1-2---------... 常用于發送 request 如下, 每一個 request 會等前一個 request 完成才做處理。1234567891011121314function getPostData() &#123; return fetch('https://jsonplaceholder.typicode.com/posts/1') .then(res =&gt; res.json())&#125;var source = Rx.Observable.fromEvent(document.body, 'click');var example = source.concatMap( e =&gt; Rx.Observable.from(getPostData()));example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); concatMap 還有第二個參數是一個 selector callback，這個 callback 會傳入四個參數，分別是: 外部 observable 送出的元素 內部 observable 送出的元素 外部 observable 送出元素的 index 內部 observable 送出元素的 index 123456789101112131415function getPostData() &#123; return fetch('https://jsonplaceholder.typicode.com/posts/1') .then(res =&gt; res.json())&#125;var source = Rx.Observable.fromEvent(document.body, 'click');var example = source.concatMap( e =&gt; Rx.Observable.from(getPostData()), (e, res, eIndex, resIndex) =&gt; res.title);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 29. switchMapswitchMap = map+switchswitchMap 跟 concatMap 一樣有第二個參數 selector callback 可用來回傳我們要的值1234567891011var source = Rx.Observable.fromEvent(document.body, 'click');var example = source .map(e =&gt; Rx.Observable.interval(1000).take(3)) .switch(); example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 相当于:123456789101112var source = Rx.Observable.fromEvent(document.body, 'click');var example = source .switchMap( e =&gt; Rx.Observable.interval(100).take(3) ); example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); Marble Diagram:123source : -----------c--c-----------------... concatMap(c =&gt; Rx.Observable.interval(100).take(3))example: -------------0--0-1-2-----------... switchMap 用在HTTP request, 雖然我們發送了多個 request 但最後真正印出來的 log 只會有一個1234567891011121314function getPostData() &#123; return fetch('https://jsonplaceholder.typicode.com/posts/1') .then(res =&gt; res.json())&#125;var source = Rx.Observable.fromEvent(document.body, 'click');var example = source.switchMap( e =&gt; Rx.Observable.from(getPostData()));example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 30. mergeMapmergeMap = map + mergeAll1234567891011var source = Rx.Observable.fromEvent(document.body, 'click');var example = source .map(e =&gt; Rx.Observable.interval(1000).take(3)) .mergeAll(); example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 相当于123456789101112var source = Rx.Observable.fromEvent(document.body, 'click');var example = source .mergeMap( e =&gt; Rx.Observable.interval(100).take(3) ); example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); Marble Diagram:123source : -----------c-c------------------... concatMap(c =&gt; Rx.Observable.interval(100).take(3))example: -------------0-(10)-(21)-2----------... mergeMap 也能傳入第2個參數和concatMap是一样的，但 mergeMap传入第3个参数限制并行数量(限制但是不是阻止的意思)下面的例子，若连续点击4下，第4个HTTP request需要等第1个结束以后才可以发送123456789101112131415function getPostData() &#123; return fetch('https://jsonplaceholder.typicode.com/posts/1') .then(res =&gt; res.json())&#125;var source = Rx.Observable.fromEvent(document.body, 'click');var example = source.mergeMap( e =&gt; Rx.Observable.from(getPostData()), (e, res, eIndex, resIndex) =&gt; res.title, 3);example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); switchMap, mergeMap, concatMap 相同和不同的地方共同的特性: 可以把第一個參數所回傳的 promise 物件直接轉成 observable12345678910111213141516function getPersonData() &#123; return fetch('https://jsonplaceholder.typicode.com/posts/1') .then(res =&gt; res.json())&#125;var source = Rx.Observable.fromEvent(document.body, 'click');// 不需要写成 // var example = source.concatMap(e =&gt; Rx.Observable.from(getPersonData()));var example = source.concatMap(e =&gt; getPersonData()); //直接回傳 promise 物件example.subscribe(&#123; next: (value) =&gt; &#123; console.log(value); &#125;, error: (err) =&gt; &#123; console.log('Error: ' + err); &#125;, complete: () =&gt; &#123; console.log('complete'); &#125;&#125;); 12 11111. aaaaaa1bbbbbb 12 11111. aaaaaa1bbbbbb 12 11111. aaaaaa1bbbbbb 12 11111. aaaaaa1bbbbbb 12 11111. aaaaaa1bbbbbb 12 11111. aaaaaa1bbbbbb 12 11111. aaaaaa1bbbbbb 12 11111. aaaaaa1bbbbbb 12","tags":[{"name":"rxjs","slug":"rxjs","permalink":"https://zm8.github.io/tags/rxjs/"}]},{"title":"BlueLake博客主题的详细配置(转)","date":"2017-09-27T23:24:00.000Z","path":"2017/09/28/BlueLake博客主题的详细配置(转)/","text":"原文链接 开始之前BlueLake主题写了有一段时间了，经常会有朋友发消息给我问一些配置的问题，这篇博文主要也是为了解决这些问题。主题以简洁轻量自居(实则简陋)，去掉了Jquery和Fancybox,用原生JS实现站内搜索功能和回到顶部效果。这个主题只是一个小小的雏形，期待您来帮助它成长。 在阅读本文之前，假定您已经成功安装了Hexo，并使用 Hexo 提供的命令创建了一个静态博客。Hexo是一个快速、简洁且高效的博客框架。Hexo基于Node.js ，使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 需要特别注意的是Hexo有两个_config.yml配置文件，一份位于站点根目录下，主要包含 Hexo 站点本身的配置，下文中会称为根_config.yml；另一份位于主题目录下（themes/主题名/_config.yml），这份配置由主题作者提供，主要用于配置主题相关的选项,下文中会称为主题_config.yml。 1. 安装您可以直接到BlueLake发布页下载，然后解压拷贝到themes目录下，修改配置即可。不过我还是推荐使用GIT来checkout代码，之后也可以通过git pull来快速更新。 1.1 安装主题在根目录下打开终端窗口：git bash1$ git clone https://github.com/chaooo/hexo-theme-BlueLake.git themes/BlueLake 1.2 安装主题渲染器BlueLake是基于jade和stylus写的，所以需要安装hexo-renderer-jade和hexo-renderer-stylus来渲染。git bash12$ npm install hexo-renderer-jade@0.3.0 --save$ npm install hexo-renderer-stylus --save 1.3 启用主题打开根_config.yml配置文件，找到theme字段，将其值改为BlueLake(先确认主题文件夹名称是否为BlueLake)。根_config.yml_config.yml1theme: BlueLake 1.4 验证首先启动 Hexo 本地站点，并开启调试模式：git bash1$ hexo s --debug 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.此时即可使用浏览器访问 http://localhost:4000，检查站点是否正确运行。 1.5 更新主题今后若主题添加了新功能正是您需要的，您可以直接git pull来更新主题。git bash12cd themes/BlueLakegit pull 2. 配置2.1 配置网站头部显示文字打开根_config.yml，找到：根_config.yml_config.yml1234title: subtitle: description: author: title和subtitle分别是网站主标题和副标题，会显示在网站头部；description在网站界面不会显示，内容会加入网站源码的meta标签中，主要用于SEO；author就填写网站所有者的名字，会在网站底部的Copyright处有所显示。 2.2 设置语言该主题目前有七种语言：简体中文（zh-CN），繁体中文（zh-TW），英语（en），法语（fr-FR），德语（de-DE），韩语 （ko）,西班牙语（es-ES）；例如选用简体中文，在根_config.yml配置如下：根_config.yml_config.yml1language: zh-CN 2.3 设置菜单打开主题_config.yml，找到：主题_config.ymlthemes/BlueLake/_config.yml12345678910111213menu: - page: home directory: . icon: fa-home - page: archive directory: archives/ icon: fa-archive # - page: about # directory: about/ # icon: fa-user - page: rss directory: atom.xml icon: fa-rss 主题默认是展示四个菜单，即主页home，归档archive，关于about，订阅RSS；about需要手动添加，RSS需要安装插件，若您并不需要，可以直接注释掉。每个页面底部的footer中联系博主的三个图标分别是邮箱，微博主页链接地址，GitHUb个人页链接地址，直接使用主题_config.yml中about页面的配置，若不需要about页面，只需要如下配置就好：主题_config.ymlthemes/BlueLake/_config.yml12345# About page about: email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 github_url: ## github主页链接地址 2.3.1 添加about页此主题默认page页面是关于我页面的布局，在根目录下打开命令行窗口，生成一个关于我页面：git bash1$ hexo new page 'about' 打开主题_config.yml，补全关于我页面的详细信息：主题_config.ymlthemes/BlueLake/_config.yml12345678# About page about: photo_url: ## 头像的链接地址 email: ## 个人邮箱 weibo_url: ## 微博主页链接地址 weibo_name: ## 微博用户名 github_url: ## github主页链接地址 github_name: ## github用户名 当然您也可以自定义重新布局about页面，只需要修改layout/page.jade模板就好。 2.3.2 安装 RSS(订阅) 和 sitemap(网站地图) 插件在根目录下打开命令行窗口：git bash123$ npm install hexo-generator-feed --save$ npm install hexo-generator-sitemap --save$ npm install hexo-generator-baidu-sitemap --save 添加主题_config.yml配置：主题_config.ymlthemes/BlueLake/_config.yml1234567891011121314Plugins: hexo-generator-feed hexo-generator-sitemap hexo-generator-baidu-sitemapfeed: type: atom path: atom.xml limit: 20sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 2.4 添加本地搜索默认本地搜索是用原生JS写的，但还需要HEXO插件创建的JSON数据文件配合。安装插件hexo-generator-json-content来创建JSON数据文件：git bash1$ npm install hexo-generator-json-content@2.2.0 --save 然后在根_config.yml添加配置：根_config.yml_config.yml123456789101112131415161718jsonContent: meta: false pages: false posts: title: true date: true path: true text: true raw: false content: false slug: false updated: false comments: false link: false permalink: false excerpt: false categories: false tags: true 最后在主题_config.yml添加配置：主题_config.ymlthemes/BlueLake/_config.yml1local_search: true 2.5 修改站点图标站点图标存放在主题的Source目录下，已经默认为您准备了两张图片。您也可以自己设计站点LOGO。您需要准备一张ico格式并命名为 favicon.ico ，请将其放入hexo目录的source文件夹，建议大小：32px X 32px。您需要为苹果设备添加网站徽标，请命名为 apple-touch-icon.png 的图像放入hexo目录的“source”文件夹中，建议大小为：114px X 114px。(有很多网站都可以在线生成ico格式的图片。) 2.6 添加站点关键字请在hexo目录的根_config.yml中添加keywords字段，如：根_config.yml_config.yml1234567# Sitetitle: Hexosubtitle: 副标题description: 网站简要描述,如：Charles·Zheng's blog.keywords: 网站关键字, key, key1, key2, key3author: Charleslanguage: zh-CN 2.7 其他配置主题_config.yml的其他配置 show_category_count——是否显示分类下的文章数。 widgets_on_small_screens——是否在小屏显示侧边栏，若true,则侧边栏挂件将显示在底部。主题_config.ymlthemes/BlueLake/_config.yml 12show_category_count: true widgets_on_small_screens: true 3.集成第三方服务3.1 添加评论目前主题集成六种第三方评论，分别是多说评论、Disqus评论、来必力评论、友言评论、网易云跟帖评论、畅言评论，多说马上就要停止服务了，友言好像也没怎么维护,目前我已把自己的博客评论从多说转移到畅言了，在国内目前网易云跟帖和畅言还不错。 注册并获得代码。 若使用多说评论，注册多说后获得short_name。 若使用Disqus评论，注册Disqus后获得short_name。 若使用来必力评论，注册来必力,获得data-uid。 若使用友言评论，注册友言,获得uid。 若使用网易云跟帖评论，注册网易云跟帖,获得productKey。 若使用畅言评论，注册畅言，获得appid，appkey。 配置主题_config.yml：主题_config.ymlthemes/BlueLake/_config.yml12345678910#Cmmentscomment: duoshuo: ## duoshuo_shortname disqus: ## disqus_shortname livere: ## 来必力(data-uid) uyan: ## 友言(uid) cloudTie: ## 网易云跟帖(productKey) changyan: ## 畅言需在下方配置两个参数，此处不填。 appid: ## 畅言(appid) appkey: ##畅言(appkey) 3.2 百度统计 登录百度统计，定位到站点的代码获取页面。 复制//hm.baidu.com/hm.js?后面那串统计脚本id(假设为：8006843039519956000) 配置主题_config.yml:主题_config.ymlthemes/BlueLake/_config.yml 1baidu_analytics: 8006843039519956000 注意： baidu_analytics不是你的百度id或者百度统计id如若使用谷歌统计，配置方法与百度统计类似。 3.3 卜算子阅读次数统计主题_config.ymlthemes/BlueLake/_config.yml1busuanzi: true 若设置为true将计算文章的阅读量(Hits)，并显示在文章标题下的小手图标旁。 3.4 微博秀微博秀挂件的代码放在layout/_widget/weibo.jade下，需要您去微博开放平台获取您自己的微博秀代码来替换。 登录微博开放平台，选择微博秀。 为了与主题风格统一，作如下配置 基础设置：高400px；勾选宽度自适应；颜色选择白色； 样式设置：主字色#333；链接色#40759b；鼠标悬停色#f7f8f8； 模块设置：去掉标题、边框、粉丝的勾选框，只留微博。 复制代码里src=&quot;&quot;里引号包裹的内容，替换到layout/_widget/weibo.jadeweibo.jadelayout/_widget/weibo.jade1234.widget .widget-title i(class='fa fa-weibo')= ' ' + __('新浪微博') iframe(width=\"100%\",height=\"400\",class=\"share_self\",frameborder=\"0\",scrolling=\"no\",src=\"http://widget.weibo.com/weiboshow/index.php?language=&amp;width=0&amp;height=400&amp;fansRow=2&amp;ptype=1&amp;speed=0&amp;skin=5&amp;isTitle=0&amp;noborder=0&amp;isWeibo=1&amp;isFans=0&amp;uid=1700139362&amp;verifier=85be6061&amp;colors=d6f3f7,ffffff,333,40759b,f7f8f8&amp;dpc=1\") 这只是为了和主题的风格统一，当然您也可以自由随意发挥。 注意：最主要是是要把src里uid=和verifier=后面的字段替换为您自己代码里的就好。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://zm8.github.io/tags/hexo/"}]},{"title":"Hexo3.2+GitHub搭建静态博客(转)","date":"2017-09-27T23:24:00.000Z","path":"2017/09/28/Hexo3-2-github搭建静态博客(转)/","text":"原文链接 开始之前在安装hexo之前，必须确认你已经安装了Node.js和Git。 1.创建GitHub仓库注册GitHub账号，创建一个以”用户名.github.io”命名的仓库，如我的用户名为chaooo,那我的仓库名为：chaooo.github.io，仓库默有master分支，用于托管生成的静态文件，再新建一个develop(名字自定)分支，用于托管后台文件，方便以后换电脑时后台文件不会丢失。 2.配置Git设置Git的用户名和邮件地址（邮箱就是你注册Github时候的邮箱），打开Git Bash,键入：12$ git config --global user.name \"username\"$ git config --global user.email \"email@example.com\" 3.本地Git与GitHub建立联系这里介绍SSH的配置，先检查电脑是否已经有SSH1$ ls -al ~/.ssh 如果不存在就没有关系，如果存在的话，直接删除.ssh文件夹里面所有文件。输入以下指令后，一路回车就好：1$ ssh-keygen -t rsa -C \"emailt@example.com\" 然后键入以下指令：12$ ssh-agent -s$ ssh-add ~/.ssh/id_rsa 如果出现这个错误:Could not open a connection to your authentication agent，则先执行如下命令即可：1$ ssh-agent bash 再重新输入指令：1$ ssh-add ~/.ssh/id_rsa 到了这一步，就可以添加SSH key到你的Github账户了。键入以下指令，拷贝Key（先拷贝了，等一下可以直接粘贴）：1$ clip &lt; ~/.ssh/id_rsa.pub 在github上点击你的头像–&gt;Your profile–&gt;Edit profile–&gt;SSH and GPG keys–&gt;New SSH keyTitle自己随便取，然后这个Key就是刚刚拷贝的，你直接粘贴就好（也可以文本打开id_rsa.pub复制其内容），最后Add SSH key。最后还是测试一下吧，键入以下命令：1$ ssh -T git@github.com 你可能会看到有警告，没事，输入“yes”就好。 4.初始化hexo文件夹到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址。在E盘或是你喜爱的文件夹下，右键Git Bash Here: 键入git clone -b develop &lt;刚复制的地址&gt;12$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git$ mkdir Hexo-admin Hexo安装配置1.Hexo初始化进入Hexo-admin文件夹1$ cd Hexo-admin 接下来只需要使用 npm 即可完成 Hexo 的安装:1$ npm install -g hexo-cli 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件:12$ hexo init$ npm install 接下来也可以本地预览博客，执行下列命令,然后到浏览器输入localhost:4000看看。12$ hexo generate$ hexo server 输入Ctrl+C停止服务。 2.Hexo配置用编辑器打开 Hexo-admin/ 下的配置文件_config.yml找到：12345# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: repository: 到GitHub的chaooo.github.io仓库下，点击Clone or download,复制里面的HTTPS地址到repository:，添加branch: master。123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/chaooo/chaooo.github.io.git branch: master 3.完成部署最后一步，快要成功了，键入指令：123$ npm install hexo-deployer-git --save$ hexo generate$ hexo deploy 输入弹出框的用户名与密码(首次使用git会弹出)。OK，我们的博客就已经完全搭建起来了，在浏览器输入（当然，是你的Repository名），例如我的：chaooo.github.io/每次修改本地文件后，需要键入hexo generate才能保存，再键入hexo deploy上传文件。成功之后命令行最后两句大概是这样：123To https://github.com/chaooo/chaooo.github.io.git 7f3b50a..128a10d HEAD -&gt; masterINFO Deploy done: git 当然，不要忘了回退到父文件夹提交网站相关的文件以备今后迁移，依次执行git add .、git commit -m “…”、git push origin develop。 日常操作1.写文章执行new命令，生成指定名称的文章至 Admin-blog\\source_posts\\文章标题.md 。1$ hexo new [layout] \"文章标题\" #新建文章 然后用编辑器打开“文章标题.md”按照Markdown语法书写文章。 其中layout是可选参数，默认值为post。到 scaffolds 目录下查看现有的layout。当然你可以添加自己的layout， 同时你也可以编辑现有的layout，比如post的layout默认是 hexo\\scaffolds\\post.md1234title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;tags:--- 我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：12345title: &#123; &#123; title &#125; &#125;date: &#123; &#123; date &#125; &#125;categories:tags:--- 文件标题也是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围。请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示；所有文件&quot;：&quot;后面都必须有个空格，不然会报错。 2.提交每次在本地对博客进行修改后，先执行下列命令提交网站相关的文件。123$ git add .$ git commit -m \"...\"$ git push origin develop 然后才执行hexo generate -d发布网站到master分支上。1$ hexo generate -d 3.本地仓库丢失当你想在其他电脑工作，或电脑重装系统后，安装Git与Node.js后，可以使用下列步骤： 3.1拷贝仓库1$ git clone -b develop https://github.com/chaooo/chaooo.github.io.git 3.2配置Hexo在本地新拷贝的chaooo.github.io文件夹下通过Git bash依次执行下列指令:1234$ npm install -g hexo-cli$ npm install hexo$ npm install$ npm install hexo-deployer-git --save 小Tips:hexo 命令1234567891011121314hexo new \"postName\" #新建文章hexo new page \"pageName\" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHubhexo help # 查看帮助hexo version #查看Hexo的版本hexo deploy -g #生成加部署hexo server -g #生成加预览#命令的简写hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy","tags":[{"name":"hexo","slug":"hexo","permalink":"https://zm8.github.io/tags/hexo/"}]},{"title":"github博客迁移(转)","date":"2017-09-27T23:24:00.000Z","path":"2017/09/28/github博客迁移(转)/","text":"原文链接 由于github博客在国内访问非常慢而且经常不稳定，百度爬虫也无法抓取github博客内容，所以决定将博客迁移至码云。 1.迁移代码把代码从github迁移至码云（oschina）。首先，你要先在码云注册一个账号，和GitHub操作基本一样，这里不再赘述。码云的Pages服务基本和GitHub的一样，不过码云的Pages服务更灵活一些。在GitHub上，可以新建一个以用户名命名的仓库，将网站代码放在master分支下，即可自动部署到：http://用户名.github.io/，若其他命名的仓库则新建一个gh-pages的分支，网站代码放在gh-pages下，，即可自动部署到：http://用户名.github.io/仓库名/。对于码云，基本和GitHub一样，不过还需要手动开启Pages服务，而且其他仓库虽然默认在osc-pages下，但可自定到自己喜欢的分支上。代码迁移步骤如下： 1.1 新建码云项目以我自己的博客为例，项目地址：https://github.com/chaooo/chaooo.github.io.git。它在Github上的Pages地址是：http://chaooo.github.io如果想把它转移到码云Pages，只需要登录你的码云账户，点击右上角的+号，选择新建项目: 1.2 开启pages服务然后点击创建，项目会在后台自动导入，导入成功后，点击菜单栏的Pages,码云默认的Pages服务分支是osc-pages，但是你也已选择自己静态页面所在的分支，这里我的博客项目的静态页面分支是master，选择master并点击启动服务。至此，博客已经部署成功，访问提供的地址：http://chaoo.oschina.io即可查看到我的博客。 2.修改hexo配置打开博客根目录的_config.yml文件，找到：12345678910# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://chaooo.github.io# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repository: https://github.com/chaooo/chaooo.github.io.git branch: master 修改为(根据自己的仓库地址修改)：1234567891011121314# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'#url: http://chaooo.github.iourl: http://chaoo.oschina.io# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:#- type: git# repository: https://github.com/chaooo/chaooo.github.io.git# branch: master- type: git repository: https://git.oschina.net/chaoo/chaoo.git branch: master 然后执行下面命令，以重新生成baidusitemap.xml。1hexo generate -d 3.验证网站百度搜索引擎入口：百度搜索引擎入口。先添加域名，然后验证网站，这里统一都使用文件验证，就是下载对应的html文件，放到域名根目录下，也就收博客根目录下的public/下面 。然后部署到服务器,输入地址：http://chaoo.oschina.io/baidu_verify_wjJ25Q3cv2.html能访问到就可以点验证按钮(按照百度的引导步骤就好)。 4.sitemap提交直接点击sitemap填写数据文件地址：http://chaoo.oschina.io/baidusitemap.xml,输入验证码提交。 自动推送自动推送很简单，就是在你代码里面嵌入自动推送JS代码，在页面被访问时，页面URL将立即被推送给百度，可将代码添加到\\themes\\landscape\\layout\\_partial\\after_footer.ejs中的最下面就行。代码如下：1234567891011121314&lt;script&gt;(function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(bp, s);&#125;)();&lt;/script&gt; 这样就可以等待百度收录了。","tags":[{"name":"hexo","slug":"hexo","permalink":"https://zm8.github.io/tags/hexo/"}]}]